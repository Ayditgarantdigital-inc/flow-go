// Code generated by mockery v1.0.0. DO NOT EDIT.

package mock

import context "context"
import flow "github.com/dapperlabs/flow-go/protobuf/services/access"
import grpc "google.golang.org/grpc"
import mock "github.com/stretchr/testify/mock"

// AccessAPIClient is an autogenerated mock type for the AccessAPIClient type
type AccessAPIClient struct {
	mock.Mock
}

// ExecuteScriptAtBlockHeight provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) ExecuteScriptAtBlockHeight(ctx context.Context, in *flow.ExecuteScriptAtBlockHeightRequest, opts ...grpc.CallOption) (*flow.ExecuteScriptResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.ExecuteScriptResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.ExecuteScriptAtBlockHeightRequest, ...grpc.CallOption) *flow.ExecuteScriptResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecuteScriptResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.ExecuteScriptAtBlockHeightRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecuteScriptAtBlockID provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) ExecuteScriptAtBlockID(ctx context.Context, in *flow.ExecuteScriptAtBlockIDRequest, opts ...grpc.CallOption) (*flow.ExecuteScriptResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.ExecuteScriptResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.ExecuteScriptAtBlockIDRequest, ...grpc.CallOption) *flow.ExecuteScriptResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecuteScriptResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.ExecuteScriptAtBlockIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecuteScriptAtLatestBlock provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) ExecuteScriptAtLatestBlock(ctx context.Context, in *flow.ExecuteScriptAtLatestBlockRequest, opts ...grpc.CallOption) (*flow.ExecuteScriptResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.ExecuteScriptResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.ExecuteScriptAtLatestBlockRequest, ...grpc.CallOption) *flow.ExecuteScriptResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecuteScriptResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.ExecuteScriptAtLatestBlockRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccount provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetAccount(ctx context.Context, in *flow.GetAccountRequest, opts ...grpc.CallOption) (*flow.GetAccountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.GetAccountResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetAccountRequest, ...grpc.CallOption) *flow.GetAccountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.GetAccountResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByHeight provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetBlockByHeight(ctx context.Context, in *flow.GetBlockByHeightRequest, opts ...grpc.CallOption) (*flow.BlockResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.BlockResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetBlockByHeightRequest, ...grpc.CallOption) *flow.BlockResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.BlockResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetBlockByHeightRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByID provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetBlockByID(ctx context.Context, in *flow.GetBlockByIDRequest, opts ...grpc.CallOption) (*flow.BlockResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.BlockResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetBlockByIDRequest, ...grpc.CallOption) *flow.BlockResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.BlockResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetBlockByIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeaderByHeight provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetBlockHeaderByHeight(ctx context.Context, in *flow.GetBlockHeaderByHeightRequest, opts ...grpc.CallOption) (*flow.BlockHeaderResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.BlockHeaderResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetBlockHeaderByHeightRequest, ...grpc.CallOption) *flow.BlockHeaderResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.BlockHeaderResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetBlockHeaderByHeightRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeaderByID provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetBlockHeaderByID(ctx context.Context, in *flow.GetBlockHeaderByIDRequest, opts ...grpc.CallOption) (*flow.BlockHeaderResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.BlockHeaderResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetBlockHeaderByIDRequest, ...grpc.CallOption) *flow.BlockHeaderResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.BlockHeaderResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetBlockHeaderByIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollectionByID provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetCollectionByID(ctx context.Context, in *flow.GetCollectionByIDRequest, opts ...grpc.CallOption) (*flow.CollectionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.CollectionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetCollectionByIDRequest, ...grpc.CallOption) *flow.CollectionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.CollectionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetCollectionByIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventsForBlockIDs provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetEventsForBlockIDs(ctx context.Context, in *flow.GetEventsForBlockIDsRequest, opts ...grpc.CallOption) (*flow.EventsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.EventsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetEventsForBlockIDsRequest, ...grpc.CallOption) *flow.EventsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.EventsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetEventsForBlockIDsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventsForHeightRange provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetEventsForHeightRange(ctx context.Context, in *flow.GetEventsForHeightRangeRequest, opts ...grpc.CallOption) (*flow.EventsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.EventsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetEventsForHeightRangeRequest, ...grpc.CallOption) *flow.EventsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.EventsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetEventsForHeightRangeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestBlock provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetLatestBlock(ctx context.Context, in *flow.GetLatestBlockRequest, opts ...grpc.CallOption) (*flow.BlockResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.BlockResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetLatestBlockRequest, ...grpc.CallOption) *flow.BlockResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.BlockResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetLatestBlockRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestBlockHeader provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetLatestBlockHeader(ctx context.Context, in *flow.GetLatestBlockHeaderRequest, opts ...grpc.CallOption) (*flow.BlockHeaderResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.BlockHeaderResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetLatestBlockHeaderRequest, ...grpc.CallOption) *flow.BlockHeaderResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.BlockHeaderResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetLatestBlockHeaderRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransaction provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetTransaction(ctx context.Context, in *flow.GetTransactionRequest, opts ...grpc.CallOption) (*flow.TransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.TransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetTransactionRequest, ...grpc.CallOption) *flow.TransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetTransactionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionResult provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) GetTransactionResult(ctx context.Context, in *flow.GetTransactionRequest, opts ...grpc.CallOption) (*flow.TransactionResultResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.TransactionResultResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.GetTransactionRequest, ...grpc.CallOption) *flow.TransactionResultResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResultResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.GetTransactionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Ping provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) Ping(ctx context.Context, in *flow.PingRequest, opts ...grpc.CallOption) (*flow.PingResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.PingResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.PingRequest, ...grpc.CallOption) *flow.PingResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.PingResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.PingRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransaction provides a mock function with given fields: ctx, in, opts
func (_m *AccessAPIClient) SendTransaction(ctx context.Context, in *flow.SendTransactionRequest, opts ...grpc.CallOption) (*flow.SendTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flow.SendTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *flow.SendTransactionRequest, ...grpc.CallOption) *flow.SendTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.SendTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *flow.SendTransactionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
